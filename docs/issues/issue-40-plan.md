# Issue #40 設計メモ: AI チャットでのスケジュール調整（MVP）

## 目的（Issue本文の再整理）

- スタッフの急な休み、利用者都合による日時変更が発生したときに、変更処理（誰に振る／どう動かす）を短時間で決められるようにする。
- 既存データや画一的ルールでは表現しきれない要因があるため、まずは「提案の起点」を作り、人が判断できる材料（候補と理由）を提示する。

## スコープ（本スレで合意したMVP）

- 対象事象
  - スタッフの急な休み（当日〜数日）
  - 利用者都合による日時変更（まずは1件の移動を想定）
- 出力
  - **変更案（操作列）を 1〜3 案** 提示（玉突き／多段の入れ替えを含む）
  - 各案に対して「この案で移動するシフト一覧」「理由（制約を満たす／変更回数が少ない等）」を表示
  - UI上はチャット風でも良いが、入力はウィザードで構造化する（方針A）
- 適用
  - **提案のみ**。DB更新は既存UI操作で人が反映する。

## 重要な設計論点: 「チャット」と自然文

自然文チャット入力をそのまま解釈するには、次のいずれかが必要。

### 方針A（推奨・LLMなし）: “チャット風UI”だが入力は構造化

- UIはチャットの見た目（会話ログ）にするが、入力はボタン／選択肢／セレクトで構造化する。
- 例
  - 「何が起きましたか？」→ [スタッフが休み] [利用者の時間変更]
  - 「対象スタッフは？」→ staff select
  - 「期間は？」→ 日付レンジ
  - 「対象の予定は？」→ 週次画面のシフトから選択 / リストから選択
- 長所
  - 実装が堅い、監査・再現が容易、個人情報送信リスクなし
- 短所
  - 自然文の自由度はない

※ 本Issueで解決したい価値は「単に空いている人を列挙」ではなく、
**特定ヘルパーしか対応できない制約**がある中で、
**玉突きで入れ替えを成立させる変更案**を短時間で出すこと。

### 方針B（将来）: LLMで自然文を構造化（匿名化して送信）

- 例: 「今日、佐藤さんが熱で休み。午前のAさん宅どうする？」
- LLMは「入力→構造化(ChangeRequest)」と「説明文生成」に限定し、**最終判断/適用は人**。
- データ送信方針、ログ、利用回数制限、プロンプト管理が必要。

## データモデル（提案）

### ChangeRequest（変更リクエスト）

アプリ外の出来事を、アプリ内に取り込むための構造化データ。

- id
- office_id
- type: 'staff_absence' | 'client_datetime_change'
- payload
  - staff_absence:
    - staff_id
    - start_date / end_date
    - note（自由記述: 暗黙知・注意点）
  - client_datetime_change:
    - shift_id（変更対象）
    - new_start_time / new_end_time（or new_date + time）
    - note
- created_by, created_at

※ MVPではDBテーブル化せず、セッション内（クライアント状態）でも開始できる。ただし将来の監査・再利用を考えるとDB化が望ましい。

### Suggestion（変更案）

提案結果を「人が理解できる単位」に落とすため、候補スタッフ一覧ではなく **操作列** として表現する。

- title: 例「変更回数が最小の案」
- operations: Array<{ type: 'change_staff'; shift_id; new_staff_id; reason? }>
- summary:
  - moved_shifts_count
  - affected_staff_count
  - notes（説明文）
- rationale: Array<{ code; message }>
  - 例: { code: 'no_conflict', message: '全ての割当で時間重複なし' }
  - 例: { code: 'allowed', message: '全ての割当が担当許可リスト内' }

※ MVPでは `operations` は `changeShiftStaffAction` を人が手で実行できる形に落とす（自動適用はしない）。

## 提案エンジン（決定論ロジック）の骨子

ここが本Issueのコア。
LLMなしでも「玉突き」を出すには、**制約充足 + 探索（最小変更優先）**が必要。

ポイントは2つ:

1. 変更案は「なるべく少ない変更回数」であるほど現場で使いやすい
2. 変更案の各ステップは、既存の操作（担当者変更）で人が再現できる必要がある

### ケース1: スタッフ急休

入力: staff_id + 期間

0. 対象期間のそのスタッフのシフト一覧を取得（予定・未完了のみ）
1. 各シフトについて「再割当プラン」を探索して提示する

#### 再割当プラン探索（玉突き）

入力: 1つの対象シフト S（元担当 staff が不在）

- まずは直接再割当（深さ0）
  - S を割り当て可能かつ時間重複しない staff を探す
- 直接が無理なら、玉突きを探索（深さ1〜N）
  - 候補 staff X が S の時間帯で埋まっている場合
    - X の「重複しているシフト T」を1つ選び、T を別の staff に移せないか探索
    - 見つかれば、操作列は [T の担当変更, S の担当変更] となる

探索は BFS（幅優先）に寄せて **変更回数が少ない案を優先**し、深さ N（例: 2〜3）で打ち切る。

制約（Phase 1で適用）:

- office 境界
- 候補スタッフは `role==='helper'` に限定
- サービス種別適性（暫定）: staff の `service_type_ids` で判定
- 時間重複なし（scheduledのみ）: shifts の重複チェック

制約（Phase 2以降で必須化予定）:

- 担当許可: client_staff_assignments（client_id + service_type_id）

制約（任意・データが整っていれば）:

- 稼働可能枠: staff_availabilities

スコアリング（同じ変更回数なら）:

- moved_shifts_count が少ない
- affected_staff_count が少ない
- 月間担当時間が少ない staff を優先
- staff_availabilities.priority=High を優先

結果:

- 1シフトあたり 1〜3 案の `Suggestion.operations` を返す

### ケース2: 利用者都合の日時変更（1件）

入力: shift_id + 新しい日時

1. 変更後の時間帯で、現担当スタッフが継続担当できるか（重複）をチェック
2. NGの場合、対象シフトを「再割当プラン探索」に入力し、玉突き案を提示

## 現行コードとの統合ポイント（レイヤード準拠）

- Server Actions → Service → Repository → Supabase の流れを維持
- 既存の更新系は `shifts`（担当変更・単発作成・キャンセル）に揃っている
- MVPでは「提案のみ」なので、提案の取得は新規 Action/Service を追加する形が自然

提案API（案）:

- `suggestShiftAdjustmentsAction(input)`
  - input は ChangeRequest 相当（staff_absence / client_datetime_change）
  - output は Suggestion[]（操作列 + 理由）

## 画面/導線（MVP案）

- 週次スケジュール画面に「調整相談」ボタン
- ウィザード（チャット風UIでも可）で ChangeRequest を作成
  - 例: [スタッフが休み] → staff → 期間 → 影響シフト一覧
  - 例: [利用者の時間変更] → 対象シフト → 新しい日時
- 結果として「対象シフトごとの変更案（操作列）」を表示
- 人が既存の担当者変更UIなどで反映

## 未決事項（次に決める）

- 「スタッフ急休」時の対象シフト
  - scheduled のみ / completed 除外など
- 「日時変更」時に、そもそもシフトの開始/終了を編集するUI/ActionをMVPに含めるか
  - 提案のみなら編集機能は後回しでも動くが、運用上は必要になる可能性が高い
- staff_availabilities を候補抽出で必須条件にするか
  - データ未整備ならまずは重複チェック + 許可リストから開始する

### MVP段階分け（推奨）

- MVP-0: 直接再割当のみ（深さ0）
  - まず「候補スタッフ + 理由」ではなく「S を X に変更する」単発操作として提示
- MVP-1: 玉突き深さ1（2手まで）
  - 例: X が埋まっている → X の重複シフト T を Y に移す → S を X に入れる
- MVP-2: 玉突き深さ2（3手まで）
  - 現場の複雑さに合わせて段階的に拡張

※ 深さを上げるほど計算量が増えるため、候補数の上限・探索の打ち切り条件が必要。
