# Issue #32 実装計画: シフトの連続入力の制限（30分インターバル）

Issue: https://github.com/ebi311/rhubarb/issues/32

## 目的 / 背景

#Truetrue
-N
error: null,\*\*前のシフト終了→次のシフト開始**の間に**最低30分\*\*のインターバルを必須化する。

- 30分ちょうどは許容（例: 10:00終了 → 10:30開始は OK）
- 30分未満は拒否
- 「後ろ詰め」「前詰め」の両方向で同じルール（対称）を適用する

:

- 基本スケジュール（作成/更新/一括作成/一括更新）: `BasicScheduleService.assertNoOverlap()` → `BasicScheduleRepository.findOverlaps()`
- 週次シフト（スタッフ割当/変更時の検証）: `ShiftService.validateStaffAvailability()` → `ShiftRepository.findConflictingShifts()`

## 現状調査（関連実装）

### 基本スケジュール

- `BasicScheduleService.assertNoOverlap()` は `basicScheduleRepository.findOverlaps()` の結果が1件でもあれば `ServiceError(409)`
- `BasicScheduleRepository.findOverlaps()` は、該当スタッフに紐づく同一曜日のスケジュールを取得して **JS側で分→重複判定**している
  - 現在の重複判定: `targetStart < end && start < targetEnd`（境界一致は非重複）

### 週次シフト

- `ShiftRepository.findConflictingShifts()` は Supabase フィルタで
  - `start_time < endTime` かつ `end_time > startTime`（境界一致は非重複）
- `ShiftService.validateStaffAvailability()` は repository の結果を availability に変換するだけ（判定は repository に依存）

## 仕様の定義（判定式）

2つのシフト（時間帯）を

- 既存: $[s_1, e_1)$
- 新規: $[s_2, e_2)$
  error: Null,\

### 要件（30分インターバル）

:-N

- $e_1 + 30\text{min} \le s_2$（既存の後に30分以上）
- $e_2 + 30\text{min} \le s_1$（新規の後に30分以上）

-N

### 競合判定（対称・境界許容）

**厳密不等号** を使うことで「30分ちょうど」を非競合にする）: Error:

- $e_1 + 30\text{min} > s_2$ かつ $e_2 + 30\text{min} > s_1$

#true
30分拡張した区間」と「既存区間」の重複として扱う:

- 新規拡張: $[s_2 - 30\text{min},\ e_2 + 30\text{min})$
- 競合条件: `bufferedStart < existingEnd && existingStart < bufferedEnd`
  - ※ ここでも **`<` と `>` を厳密**にする（`<=`/`>=` は使わない）

## 実装方針（最小変更・定義を Repository に集約）

**Repository 側でバッファを適用**して“競合の定義”を一箇所に寄せる。Truetruetruetrue
error: Service 側は現状の呼び出しを維持し、返ってくる競合一覧の意味が「30分インターバル込みの競合」になる。）

### 1) 基本スケジュール: `BasicScheduleRepository.findOverlaps()`

: [src/backend/repositories/basicScheduleRepository.ts](src/backend/repositories/basicScheduleRepository.ts)

- 追加する定数: `const STAFF_SHIFT_INTERVAL_MINUTES = 30;`
- `targetStart/targetEnd` を分単位で持っているので、以下を導入
  - `const bufferedStart = targetStart - STAFF_SHIFT_INTERVAL_MINUTES;`
  - `const bufferedEnd = targetEnd + STAFF_SHIFT_INTERVAL_MINUTES;`
- JS 側フィルタ条件を差し替え
  - 変更前: `targetStart < end && start < targetEnd`
  - 変更後: `bufferedStart < end && start < bufferedEnd`

- 10:00終了→10:30開始は `bufferedStart = 10:00` となり `bufferedStart < end` が false で非競合
- 10:00終了→10:29開始は `bufferedStart = 09:59` となり競合

### 2) 週次シフト: `ShiftRepository.findConflictingShifts()`

: [src/backend/repositories/shiftRepository.ts](src/backend/repositories/shiftRepository.ts)

- 追加する定数: `const STAFF_SHIFT_INTERVAL_MINUTES = 30;`
- 引数の `startTime/endTime` を Date のまま前後に30分ずらす
  - `const bufferedStart = new Date(startTime.getTime() - 30 * 60_000);`
  - `const bufferedEnd = new Date(endTime.getTime() + 30 * 60_000);`
- Supabase の重複条件を buffered に置換
  - 変更前: `start_time.lt.${endTimeISO}` && `end_time.gt.${startTimeISO}`
  - 変更後: `start_time.lt.${bufferedEndISO}` && `end_time.gt.${bufferedStartISO}`

::::::

- 既存 `end_time == startTime - 30min` は `end_time.gt(bufferedStart)` が false になり非競合
- 既存 `start_time == endTime + 30min` は `start_time.lt(bufferedEnd)` が false になり非競合

## TDD 計画（テスト → 最小実装 → リファクタ）

### 週次シフト（既存テストの拡張）

: [src/backend/repositories/shiftRepository.test.ts](src/backend/repositories/shiftRepository.test.ts)

/変更する観点:

- `findConflictingShifts()` が `.or()` に渡すクエリ文字列に **bufferedStart/bufferedEnd の ISO** が使われること
  - 例: start=10:00Z end=11:00Z のとき、`lt` に 11:30Z、`gt` に 09:30Z が含まれる

### 基本スケジュール（Repository 単体テストを新規追加）

: [src/backend/repositories/basicScheduleRepository.test.ts](src/backend/repositories/basicScheduleRepository.test.ts)

-n:

- `findOverlaps()` の「JS側フィルタ」が30分バッファ込みで正しく動作すること

       staff / 同一 weekday 前提）:,\

1. **30分ちょうど（後ろ）**: 既存 09:00-10:00、入力 10:30-11:00 → 競合なし
2. **30分未満（後ろ）**: 既存 09:00-10:00、入力 10:29-11:00 → 競合あり
3. **30分ちょうど（前）**: 既存 09:00-10:00、入力 08:00-08:30 → 競合なし
4. **30分未満（前）**: 既存 09:00-10:00、入力 08:00-08:31 → 競合あり
5. **通常の重複**: 既存 09:00-10:00、入力 09:30-10:30 → 競合あり

#true
:

- `findOverlaps()` は Supabase から候補スケジュールを取得してから filter するため、
  - `basic_schedule_staff_assignments` の `select().in()`
  - `basic_schedules` の `select().in().eq().is()`
    を返すモックを組む
- 返す `basic_schedules` 行は `start_time/end_time` が `time with time zone` 文字列である必要がある（例: `09:00:00+09:00`）

### Service/Action のテスト

- `BasicScheduleService` / `ShiftService` は repository の返却結果に依存するため、今回の主たる境界条件は repository テストで担保する
- 既存の service テストは、409 を返す経路などが既にあるため、必要なら最小限の追加に留める

## 作業手順（ブランチ戦略含む）

1. 作業ツリーをクリーンにする（現在 `package.json` 変更、`scripts/` `test-data/` が未追跡のため、意図しない差分が混ざらないよう整理）
2. ブランチ作成: `feature/issue-32-shift-interval`（例）
3. テスト追加（失敗を確認）
   - `shiftRepository.test.ts` に buffered 条件の期待を追加
   - `basicScheduleRepository.test.ts` を新規作成
4. 実装（最小変更）
   - `basicScheduleRepository.ts` のフィルタ条件をバッファ込みに変更
   - `shiftRepository.ts` の `.or(...)` の条件を bufferedStart/bufferedEnd に変更
5. ユニットテスト実行: `pnpm test:ut --run`
6. 必要に応じてフォーマット: `pnpm format`

## 変更対象ファイル（見込み）

- [src/backend/repositories/basicScheduleRepository.ts](src/backend/repositories/basicScheduleRepository.ts)
- [src/backend/repositories/shiftRepository.ts](src/backend/repositories/shiftRepository.ts)
- [src/backend/repositories/shiftRepository.test.ts](src/backend/repositories/shiftRepository.test.ts)
- [src/backend/repositories/basicScheduleRepository.test.ts](src/backend/repositories/basicScheduleRepository.test.ts) ※新規

      error: 4ファイル想定のため、フェーズ分割は不要）

## リスク / 留意点

- `BasicScheduleService.batchUpsert()` は DB へ逐次書き込みだが、同一バッチ内で「まだDBに存在しない create 同士」の競合は検出できない（既存挙動）。
  - 今回の Issue の要件には含まれないためスコープ外とするが、将来的に必要なら「バッチ内の仮想的な競合チェック」も検討。
- 競合チェックはアプリケーションレベルの検証のため、同時更新の競合（並行書き込み）には弱い。
  - DB 制約（排他制約/トリガ等）は現状導入していないため、今回も追加しない。
