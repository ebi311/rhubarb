# Issue #65 実装計画 — 週間スケジュール調整相談リニューアル

> **注記（2026-02-24）**: 本ドキュメントは `plan-2026-02-24-10-00-v2.md` の差分を統合済み。以後は本ファイルを単一の正とし、旧 v2 は削除。

2026-02-24（追加要件反映版）  
: 2026-02-24  
Issue: #65「週間スケジュール画面：調整相談のリニューアル」

---

## 背景・調査結果

### 現状

| 要素                        | パス                                  | 状態                                                                                                                          |
| --------------------------- | ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| 既存ダイアログ              | `ShiftAdjustmentDialog/`              | "Phase 1" 表示のまま。提案取得のみ・DB 更新なし                                                                               |
| エントリポイント            | `WeeklySchedulePage.tsx` L180         | 週選択バーの「調整相談」ボタン                                                                                                |
| スタッフ変更アクション      | `src/app/actions/shifts.ts`           | `changeShiftStaffAction` — 既存流用可（戻り値は `{ oldStaffName, newStaffName }` のみ。拡張が必要）                           |
| 日時変更アクション          | `src/app/actions/shifts.ts`           | `updateShiftScheduleAction` — 既存流用可                                                                                      |
| 候補提案サービス (日時変更) | `shiftAdjustmentSuggestionService.ts` | `suggestClientDatetimeChangeAdjustments` — 「重複なし候補」の算出。新フローでは「重複ありも含む」ため**別メソッド追加**が必要 |
| 候補提案サービス (欠勤)     | `shiftAdjustmentSuggestionService.ts` | `suggestShiftAdjustments` — 新フローとは入力が異なる。削除候補                                                                |

### 新フロー要約

```
ChangeStaffDialog の「調整相談」ボタン
 └─→ AdjustmentWizardDialog（shiftId を受け取る）
       Step1: 処理選択 (「ヘルパーの変更」「日時の変更」)
        ├─ ヘルパー変更 ──→ Step2A: 候補表示（重複ありも含む）→ 選択
        │                    └─ assignStaffWithCascadeUnassignAction → 完了 + トースト
        └─ 日時変更 ─────→ Step2B: 日時入力
                             └─ Step3B: 候補表示（重複ありも含む）→ 選択
                                  └─ updateDatetimeAndAssignWithCascadeUnassignAction → 完了 + トースト
```

### 追加確定要件（2026-02-24 ユーザー確認済）

| #   | 要件                                                                                           |
| --- | ---------------------------------------------------------------------------------------------- |
| R1  | 候補スタッフ条件: **同一 Office かつ同一サービスタイプ**（クライアント担当アサイン条件は不要） |
| R2  | 重複（他の予定がある）スタッフでも候補に**表示する**                                           |
| R3  | 候補一覧に「重複している利用者名・時間帯」を合わせて表示する                                   |
| R4  | 重複ありスタッフへのアサイン変更時、重複元を**「ヘルパー割当なし」に連鎖更新**する             |
| R5  | アサイン完了後、**トーストでアラート**表示（連鎖発生時は件数を明示）                           |
| R6  | トーストクリックで**再度変更ウィザードを呼び出す**（対象: 連鎖により未割当になったシフト）     |
| R7  | 日時変更フロー（Phase 3）でも R4〜R6 と同様の連鎖更新・トーストを行う                          |

---

## フェーズ分割

### Phase 0 — 調査タスク（実装前に決定）

**目的**: 後続フェーズのブロッカーになる未確定事項を確定させる。

**確認項目**:

1. `suggestClientDatetimeChangeAdjustments` の入力スキーマ確認  
   → ヘルパー変更フロー (Step2A) で「現在の日時のまま `shiftId` だけ渡す」ことで代替スタッフ候補が返せるか  
   **仮置き**: 新フローでは **別メソッド** `suggestCandidateStaffForShift(shiftId)` を追加する（重複ありを含むため既存ロジックとは非互換）。

2. 「他の候補」のページング方針  
   → サービス側はオフセット非対応の可能性あり  
   **仮置き**: フロントエンドで全候補を一度取得し、5件単位で `page` ステートで切り出す。

3. `ChangeStaffDialog` への「調整相談」ボタン追加の UI デザイン検討  
   → `modal-action` に `btn btn-ghost` で追加（既存ボタン "閉じる" と並列）

4. ~~日時変更フローの更新処理: 2アクション連続 vs 新アクション~~  
   **→ 確定**: **統合アクション方式に変更**（後述の「統合アクション採用の理由」参照）

---

### 統合アクション採用の理由

"Plan → スタッフアサイン」を 2 アクション連続で呼ぶ仮置きだったが、追加要件（連鎖解除 R4）の以下のリスクから**統合アクション方式**に変更する。"

| 懸案                        | 2アクション連続                                    | 統合アクション                                               |
| --------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| アサイン成功 + 連鎖解除失敗 | 中途半端な状態（重複スタッフが二重割当のまま残る） | 1 Service メソッドで順次 UPDATE → エラー時は両方未実施で済む |
| 日時変更成功 + アサイン失敗 | 日時だけ変わりスタッフ未反映                       | 1 Service メソッドで順次実行                                 |
| UX 変更                     | なし（画面は同じ）                                 | なし（フロント API 呼び出しが 1本になるだけ）                |
| テスト工数                  | 2アクションのエラーケースを独立テスト              | 統合 Service メソッドのテスト 1本で済む                      |

> **注意**: Supabase は RLS 有効のため 1 HTTP リクエスト = 1 Supabase query の制約がある。厳密な DB トランザクション（ACID）は Service 層の複数 update を順次呼ぶことで代替し、途中失敗ケースをエラー分岐で制御する。

---

### Phase 1 — ウィザードシェル + エントリポイント変更

**目的**: 新ウィザードのシェルを作り、ChangeStaffDialog から起動できるようにする。旧エントリポイントを除去。

**変更範囲**:

| レイヤー | 変更内容                                                                                                                            |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| UI       | `ChangeStaffDialog.tsx`: 「調整相談」ボタン + `onStartAdjustment?: (shiftId: string) => void` props 追加                            |
| UI       | `AdjustmentWizardDialog/` ディレクトリを新規作成（Step管理シェルのみ。Step1 UI を実装）                                             |
| UI       | `WeeklySchedulePage.tsx`: 「調整相談」ボタン削除、旧 `ShiftAdjustmentDialog` 呼び出し削除、新 `AdjustmentWizardDialog` 呼び出し追加 |

**AdjustmentWizardDialog の Step 管理（Phase1 仮実装）**:

```typescript
type WizardStep =
	| 'select'
	| 'helper-candidates'
	| 'datetime-input'
	| 'datetime-candidates';
const [step, setStep] = useState<WizardStep>('select');
const handleBack = () => {
	/* step を前に戻す */
};
```

**影響ファイル候補**:

```
src/app/admin/weekly-schedules/_components/
  ChangeStaffDialog/ChangeStaffDialog.tsx          ← props 追加
  ChangeStaffDialog/ChangeStaffDialog.test.tsx     ← テスト更新
  ChangeStaffDialog/ChangeStaffDialog.stories.tsx  ← ストーリー更新
  AdjustmentWizardDialog/                          ← 新規作成
    AdjustmentWizardDialog.tsx
    AdjustmentWizardDialog.test.tsx
    AdjustmentWizardDialog.stories.tsx
    index.ts
  WeeklySchedulePage/WeeklySchedulePage.tsx        ← 呼び出し変更
  WeeklySchedulePage/WeeklySchedulePage.test.tsx   ← テスト更新（存在すれば）
```

**受け入れ条件**:

- [ ] ChangeStaffDialog に「調整相談」ボタンが表示される
- [ ] 「調整相談」クリック → AdjustmentWizardDialog が Step1（処理選択）で開く
- [ ] 戻るボタン → Step1 に戻れる
- [ ] 旧「調整相談」ボタン（週ヘッダー）が消えている
- [ ] 既存の ChangeStaffDialog の担当者変更機能が壊れていない

**テスト方針**:

- UT: Step 遷移ロジック（`select` → `helper-candidates` / `datetime-input`、戻る）
- Storybook: 各ステップのスナップショット

**リスクとロールバック**:

- 低リスク（UI のみ変更）
- Phase1 が問題なら旧ボタンを一時的に残したまま feature flag で切り替え可能

---

### Phase 2 — ヘルパー変更フロー（Step2A）【更新済】

**目的**: Step2A（ヘルパー候補表示/重複情報付, 選択, アサイン + 連鎖解除, トースト）を実装する。

#### 2-1. 型定義の追加 (`src/models/shiftActionSchemas.ts` に追記)

```typescript
// 候補スタッフ（重複情報付）— Phase 2 で追加
export const ConflictingShiftSchema = z.object({
	shiftId: z.string().uuid(),
	clientName: z.string(),
	date: z.string(), // YYYY-MM-DD
	startTime: TimeValueSchema,
	endTime: TimeValueSchema,
});

export const CandidateStaffSchema = z.object({
	staffId: z.string().uuid(),
	staffName: z.string(),
	/** 同日に重複するシフト一覧（空配列なら重複なし） */
	conflictingShifts: z.array(ConflictingShiftSchema),
});
export type CandidateStaff = z.infer<typeof CandidateStaffSchema>;

export const SuggestCandidateStaffForShiftOutputSchema = z.object({
	candidates: z.array(CandidateStaffSchema), // 上限 30 件。重複ありを含む
});
export type SuggestCandidateStaffForShiftOutput = z.infer<
	typeof SuggestCandidateStaffForShiftOutputSchema
>;

// assignStaffWithCascadeUnassignAction の入力・出力 — Phase 2 で追加
export const AssignStaffWithCascadeInputSchema = z.object({
	shiftId: z.string().uuid(),
	newStaffId: z.string().uuid(),
	reason: z.string().optional(),
});
export type AssignStaffWithCascadeInput = z.infer<
	typeof AssignStaffWithCascadeInputSchema
>;

export const AssignStaffWithCascadeOutputSchema = z.object({
	updatedShift: ShiftRecordSchema,
	/** 連鎖解除されたシフトの ID 一覧（0件の場合は空配列） */
	cascadeUnassignedShiftIds: z.array(z.string().uuid()),
});
export type AssignStaffWithCascadeOutput = z.infer<
	typeof AssignStaffWithCascadeOutputSchema
>;
```

#### 2-2. Service 追加 (`src/backend/services/shiftService.ts` にメソッド追加)

**`suggestCandidateStaffForShift(userId, shiftId)`**

| 項目             | 内容                                                                                                                            |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| 認可             | `getAdminStaff(userId)` で admin チェック                                                                                       |
| 対象シフト       | `shiftRepository.findById(shiftId)` → なければ 404                                                                              |
| 候補条件         | 同一 office の `role === 'helper'` のスタッフ、かつ `staff.service_type_ids.includes(shift.service_type_id)`                    |
| 除外             | 現在の担当スタッフ（`shift.staff_id`）は候補から除外                                                                            |
| 重複判定         | 当日の全シフトを `shiftRepository.list({ date })` で取得。各スタッフの重複シフトを `isOverlapping` で**全件**抽出               |
| 重複時の付帯情報 | 重複シフトの `clientName` は `serviceUserRepository.findById(conflictShift.client_id)` で取得し、`conflictingShifts` 配列で返却 |
| 上限             | 30 件（全件返す。ページングはフロントで行う）                                                                                   |
| 戻り値           | `SuggestCandidateStaffForShiftOutput`                                                                                           |

**`assignStaffWithCascadeUnassign(userId, shiftId, newStaffId, reason?)`**

| 項目                    | 内容                                                                                                                                                      |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 認可                    | `getAdminStaff(userId)`                                                                                                                                   |
| 対象シフト取得          | `shiftRepository.findById(shiftId)` — ステータス・過去日チェック（既存ロジック流用）                                                                      |
| 連鎖対象の特定          | `shiftRepository.list({ staffId: newStaffId, date: shift.date })` で新スタッフの当日シフト一覧を取得し、対象シフトと重複するものを `isOverlapping` で特定 |
| 実行順序（原子性）      | ① `shiftRepository.updateStaffAssignment(shiftId, newStaffId)` → ② 連鎖対象それぞれに `shiftRepository.updateStaffAssignment(cascadeShiftId, null)`       |
| ②の Repository 呼び出し | `null` を渡すことで既存の `isUnassigned = !input.staff_id` ロジックにより `is_unassigned = true` になることを確認済                                       |
| 戻り値                  | `{ updatedShift: Shift, cascadeUnassignedShiftIds: string[] }`                                                                                            |

> **原子性の注意**: ①成功 → ②失敗の場合、アサインは行われたが連鎖解除が未実施という中途半端な状態になり得る。これを避けるため ② の失敗は **Service で catch してエラーを上位に throw**し、アクション → フロントで「一部失敗」エラートーストを表示する（ロールバックはしない）。

#### 2-3. Action 追加 (`src/app/actions/shifts.ts` に追記)

```typescript
// 新規追加
export const suggestCandidateStaffForShiftAction = async (
  input: { shiftId: string },
): Promise<ActionResult<SuggestCandidateStaffForShiftOutput>> => { ... };

export const assignStaffWithCascadeUnassignAction = async (
  input: AssignStaffWithCascadeInput,
): Promise<ActionResult<AssignStaffWithCascadeOutput>> => { ... };
```

#### 2-4. フロント (`StepHelperCandidates.tsx`)

| 要素                     | 内容                                                                                                                                          |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |
| 候補カード               | スタッフ名 + `conflictingShifts.length > 0` の場合は `badge badge-warning` で「重複あり」 + 利用者名・時間帯をリスト表示                      |
| ページング               | `page` ステート。`candidates.slice(page * 5, (page + 1) * 5)`                                                                                 |
| アサイン実行             | `assignStaffWithCascadeUnassignAction` を呼ぶ                                                                                                 |
| 完了トースト（連鎖なし） | `toast.success('[スタッフ名]に変更しました')`                                                                                                 |
| 完了トースト（連鎖あり） | `toast.warning('[スタッフ名]に変更しました。[N]件の予定が未割当になりました', { onClick: () => onCascadeReopen(cascadeUnassignedShiftIds) })` |
| `onCascadeReopen` prop   | `(shiftIds: string[]) => void` — 親（AdjustmentWizardDialog）でウィザードを `shiftIds[0]` で再起動する                                        |

**影響ファイル候補**:

```
src/app/admin/weekly-schedules/_components/AdjustmentWizardDialog/
  StepHelperCandidates.tsx                         ← 新規
  StepHelperCandidates.test.tsx                    ← 新規
  StepHelperCandidates.stories.tsx                 ← 新規
src/app/actions/shifts.ts                          ← アクション追加
src/backend/services/shiftService.ts               ← メソッド追加
src/models/shiftActionSchemas.ts                   ← スキーマ追加
```

**受け入れ条件**:

- [ ] ヘルパー変更選択 → 候補（同一 Office + 同一サービスタイプ）が最大5件表示される
- [ ] 重複ありスタッフには「重複あり」バッジと利用者名・時間帯が表示される
- [ ] 候補なし時 → 「候補が見つかりませんでした」メッセージ表示
- [ ] 「他の候補」クリック → 次の5件が表示される
- [ ] 候補選択（重複なしスタッフ）→ アサイン成功 → 通常トースト → ダイアログ閉じる
- [ ] 候補選択（重複ありスタッフ）→ アサイン + 連鎖解除成功 → 連鎖トースト → ダイアログ閉じる
- [ ] 連鎖トーストクリック → 連鎖によって未割当になったシフトを対象にウィザードが再オープンされる
- [ ] 戻るボタン → Step1 に戻る

**テスト方針**:

- UT: `suggestCandidateStaffForShift` — 候補あり（重複なし）/ 候補あり（重複あり）/ 候補なし
- UT: `assignStaffWithCascadeUnassign` — 連鎖あり / 連鎖なし / 連鎖解除失敗時のエラー
- UT: `suggestCandidateStaffForShiftAction` / `assignStaffWithCascadeUnassignAction` — 認証チェック、ServiceError ハンドリング
- UT: ページング切り出しロジック
- Storybook: 候補あり（重複なし）/ 候補あり（重複あり）/ 候補なし / ローディング

**リスクとロールバック**:

- `shiftRepository.updateStaffAssignment(id, null)` で `is_unassigned = true` になることをユニットテストで事前確認すること
- 連鎖解除の部分失敗ケースは Service がエラーを throw し、フロントで「一部失敗」エラートーストを表示する設計を採用（ロールバックなし）

---

### Phase 3 — 日時変更フロー（Step2B + Step3B）【更新済】

**目的**: Step2B（日時入力）→ Step3B（日時変更後の候補表示・選択・連鎖更新・トースト）を実装する。

#### 3-1. 型定義の追加 (`src/models/shiftActionSchemas.ts` に追記)

```typescript
// updateDatetimeAndAssignWithCascadeUnassignAction の入力・出力 — Phase 3 で追加
export const UpdateDatetimeAndAssignWithCascadeInputSchema = z.object({
	shiftId: z.string().uuid(),
	newDate: JstDateInputSchema,
	newStartTime: TimeValueSchema,
	newEndTime: TimeValueSchema,
	newStaffId: z.string().uuid(),
	reason: z.string().optional(),
});
export type UpdateDatetimeAndAssignWithCascadeInput = z.infer<
	typeof UpdateDatetimeAndAssignWithCascadeInputSchema
>;

// 出力は AssignStaffWithCascadeOutputSchema と同型（Phase 2 で定義済み）を流用
```

#### 3-2. Service 追加 (`src/backend/services/shiftService.ts` にメソッド追加)

**`updateShiftScheduleAndAssignWithCascadeUnassign(userId, input)`**

| 項目               | 内容                                                                                                                                                                                                                                      |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 認可               | `getAdminStaff(userId)`                                                                                                                                                                                                                   |
| バリデーション     | `newEndTime > newStartTime` チェック                                                                                                                                                                                                      |
| 連鎖対象の特定     | 新日時で新スタッフが重複するシフトを `shiftRepository.list({ staffId: newStaffId, date: newDate })` + `isOverlapping(newRange, ...)` で特定                                                                                               |
| 実行順序（原子性） | ① `shiftRepository.updateShiftSchedule(shiftId, newDate, newStartTime, newEndTime)` → ② `shiftRepository.updateStaffAssignment(shiftId, newStaffId)` → ③ 連鎖対象それぞれに `shiftRepository.updateStaffAssignment(cascadeShiftId, null)` |
| 戻り値             | `{ updatedShift: Shift, cascadeUnassignedShiftIds: string[] }`                                                                                                                                                                            |

> 原子性の扱いは Phase 2 と同様（部分失敗は Service が throw してフロントでエラートースト）。

#### 3-3. Action 追加 (`src/app/actions/shifts.ts` に追記)

```typescript
// 新規追加
export const suggestCandidateStaffForShiftWithNewDatetimeAction = async (
  input: {
    shiftId: string;
    newDate: string;
    newStartTime: string;
    newEndTime: string;
  },
): Promise<ActionResult<SuggestCandidateStaffForShiftOutput>> => { ... };

export const updateDatetimeAndAssignWithCascadeUnassignAction = async (
  input: UpdateDatetimeAndAssignWithCascadeInput,
): Promise<ActionResult<AssignStaffWithCascadeOutput>> => { ... };
```

> **確定**: Step3B の候補取得は `suggestCandidateStaffForShiftWithNewDatetimeAction` を使用する。`suggestClientDatetimeChangeAdjustmentsAction`（重複なし候補）は本フローでは流用しない。

#### 3-4. フロント (`StepDatetimeCandidates.tsx`)

- 候補表示・ページング・バッジ表示ロジックは StepHelperCandidates と同一パターン
- アサイン実行は `updateDatetimeAndAssignWithCascadeUnassignAction` を使用
- トーストのハンドリング（連鎖あり/なし、クリックで再オープン）も Phase 2 と同一

**影響ファイル候補**:

```
src/app/admin/weekly-schedules/_components/AdjustmentWizardDialog/
  StepDatetimeInput.tsx                            ← 新規
  StepDatetimeInput.test.tsx                       ← 新規
  StepDatetimeInput.stories.tsx                    ← 新規
  StepDatetimeCandidates.tsx                       ← 新規
  StepDatetimeCandidates.test.tsx                  ← 新規
  StepDatetimeCandidates.stories.tsx               ← 新規
src/app/actions/shifts.ts                          ← アクション追加
src/backend/services/shiftService.ts               ← メソッド追加
src/models/shiftActionSchemas.ts                   ← スキーマ追加
```

**受け入れ条件**:

- [ ] 日時変更選択 → 日付・時刻入力フォームが表示される
- [ ] フォーム送信 → 候補5件表示（重複ありバッジ付き）
- [ ] 候補なし → 「候補が見つかりませんでした」メッセージ
- [ ] 「他の候補」クリック → 次の5件
- [ ] 候補選択（重複なし）→ 日時変更 + アサイン → 通常トースト → ダイアログ閉じる
- [ ] 候補選択（重複あり）→ 日時変更 + アサイン + 連鎖解除 → 連鎖トースト → ダイアログ閉じる
- [ ] 連鎖トーストクリック → 未割当になったシフトを対象にウィザード再オープン
- [ ] 戻るボタン → Step2B（日時入力）→ Step1 に戻れる

**テスト方針**:

- UT: `updateShiftScheduleAndAssignWithCascadeUnassign` — 連鎖あり / 連鎖なし / `newEndTime <= newStartTime` バリデーション
- UT: `updateDatetimeAndAssignWithCascadeUnassignAction` — 認証チェック、ServiceError ハンドリング
- Storybook: 日時入力フォーム / 候補表示（重複あり）/ 候補なし

**リスクとロールバック**:

- Step3B の候補算出は `suggestCandidateStaffForShiftWithNewDatetime` で確定（重複ありを含む）

---

### Phase 4 — 旧実装の削除・整理

**目的**: 旧「調整相談」機能の残骸を削除し、コードベースを整理する。

**削除対象ファイル**:

```
src/app/admin/weekly-schedules/_components/ShiftAdjustmentDialog/（ディレクトリごと）
  ShiftAdjustmentDialog.tsx
  ShiftAdjustmentDialog.test.tsx
  ShiftAdjustmentDialog.stories.tsx
  StaffAbsenceForm.tsx
  ClientDatetimeChangeForm.tsx
  SuggestionResults.tsx
  useShiftAdjustmentDialog.ts
  useShiftAdjustmentDialogDerived.ts
  useShiftAdjustmentDialogInternals.ts
  useShiftAdjustmentDialogState.ts
  useShiftAdjustmentDialogSubmit.ts
  shiftAdjustmentDialogHelpers.ts
  index.ts
```

**削除/整理対象アクション**:

- `src/app/actions/shiftAdjustments.ts` — `suggestShiftAdjustmentsAction` (スタッフ欠勤ユースケース) を削除
- `suggestClientDatetimeChangeAdjustmentsAction` は Phase3 で流用する場合は保持

**削除/整理対象サービスメソッド**:

- `shiftAdjustmentSuggestionService.ts` — `suggestShiftAdjustments` を削除（`suggestClientDatetimeChangeAdjustments` は保持）

**受け入れ条件**:

- [ ] 削除後もテスト全通過
- [ ] 型エラーなし (`pnpm build` でエラーなし)
- [ ] `ShiftAdjustmentDialog` へのインポートが残っていない

**テスト方針**:

- 既存テストの削除と、残存テストの確認のみ

**リスクとロールバック**:

- Phase1〜3 が完全に完成している前提で実施すること
- 削除は必ず個別 PR で行い、混在させない

---

## Action 戻り値 — トーストクリックで再オープンを実現するための設計

### `AssignStaffWithCascadeOutput` の使い方

```typescript
// フロント（StepHelperCandidates.tsx）
const result = await assignStaffWithCascadeUnassignAction(input);
handleActionResult(result, {
	onSuccess: (data) => {
		if (data.cascadeUnassignedShiftIds.length > 0) {
			toast.warning(
				`${newStaffName}に変更しました。${data.cascadeUnassignedShiftIds.length}件の予定が未割当になりました`,
				{
					autoClose: false,
					onClick: () => {
						// 最初の未割当シフトを対象にウィザードを再オープン
						onCascadeReopen(data.cascadeUnassignedShiftIds);
					},
				},
			);
		} else {
			toast.success(`${newStaffName}に変更しました`);
		}
		onComplete(); // ダイアログ閉じる
	},
});
```

### `AdjustmentWizardDialog` への `onCascadeReopen` prop の設計

```typescript
// AdjustmentWizardDialog — Phase 2/3 で追加
type Props = {
  shiftId: string;
  onClose: () => void;
};

// WeeklySchedulePage 側
const [wizardShiftId, setWizardShiftId] = useState<string | null>(null);
// ...
<AdjustmentWizardDialog
  shiftId={wizardShiftId}
  onClose={() => setWizardShiftId(null)}
/>
// トーストクリック時
const handleCascadeReopen = (shiftIds: string[]) => {
  setWizardShiftId(shiftIds[0]); // 最初の未割当シフトでウィザードを再起動
};
```

---

## 原子性・整合性リスクの整理（v2 統合反映）

### 統合アクション方式でのステップ別失敗マトリクス

#### ヘルパー変更（`assignStaffWithCascadeUnassignAction`）

| ステップ                            | 成功/失敗 | DB 状態                                                                 | ユーザーへの影響 | 対処                                                                 |
| ----------------------------------- | --------- | ----------------------------------------------------------------------- | ---------------- | -------------------------------------------------------------------- |
| ① 対象シフトへ新スタッフをアサイン  | 失敗      | 変更なし                                                                | ✅ セーフ        | エラートーストで通知                                                 |
| ① 成功 → ② 連鎖シフトを未割当に更新 | 失敗      | 対象シフト: 新スタッフ割当済 / 連鎖シフト: 旧スタッフのまま（二重割当） | ⚠️ 不整合        | エラートーストで「一部失敗」を通知。ユーザーが手動で連鎖シフトを対応 |
| ①②ともに成功                        | —         | ✅ 正常                                                                 | ✅ セーフ        | —                                                                    |

#### 日時変更（`updateDatetimeAndAssignWithCascadeUnassignAction`）

| ステップ             | 成功/失敗 | DB 状態                                                         | ユーザーへの影響 | 対処                                                             |
| -------------------- | --------- | --------------------------------------------------------------- | ---------------- | ---------------------------------------------------------------- |
| ① 日時更新           | 失敗      | 変更なし                                                        | ✅ セーフ        | エラートーストで通知                                             |
| ① 成功 → ② アサイン  | 失敗      | 日時のみ変更・スタッフ未変更                                    | ⚠️ 軽度の不整合  | エラートーストで通知。旧スタッフは引き続き担当のため実害は少ない |
| ①② 成功 → ③ 連鎖解除 | 失敗      | 日時・スタッフ変更済 / 連鎖シフト: 旧スタッフのまま（二重割当） | ⚠️ 不整合        | エラートーストで「一部失敗」を通知。ユーザーが手動対応           |
| ①②③ 全成功           | —         | ✅ 正常                                                         | ✅ セーフ        | —                                                                |

### 最小追加で安全にする方針

1. 連鎖解除は `Promise.all` で並列にせず、`for...of` の順次処理で最初の失敗時に `ServiceError` を throw する。
2. 部分失敗時のエラートーストには対象スタッフ/日時を含め、ユーザーが修正対象を特定できる文面にする。
3. `updateStaffAssignment(id, null)` により `is_unassigned = true` となる挙動は UT で事前担保する。

---

## 連鎖再オープン導線の代替案（完了ステップ埋め込み方式）

現行採用案（トーストクリック再オープン）を維持しつつ、代替として `cascade-complete` ステップを追加する方式を保持する。

- 連鎖がある場合はダイアログを閉じず `cascade-complete` を表示し、`今すぐ対応する` で `cascadeUnassignedShiftIds[0]` を対象に再初期化する。
- トーストは通知のみ（`onClick` 非依存）とし、見逃しリスクを下げる。
- 採用可否は Phase 2 実装後の操作確認で確定する。

---

## 未確定事項と決める順序（更新版）

| #   | 未確定事項                                                                                        | 決めるタイミング                           | 仮置き                                                                       |
| --- | ------------------------------------------------------------------------------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |
| 1   | Step3B の候補算出方式                                                                             | **確定済**                                 | `suggestCandidateStaffForShiftWithNewDatetime` を使用（重複あり候補を含む）  |
| 2   | 連鎖解除の部分失敗のロールバック方針                                                              | Phase 2 着手時                             | ロールバックなし。エラートーストを表示して状態をユーザーに伝える             |
| 3   | トーストクリックで「複数連鎖シフトがある場合」最初の 1 件のみ対象にするか、全件ドリルダウンするか | Phase 2 実装時                             | 最初の 1 件のみ対象（`cascadeUnassignedShiftIds[0]`）でウィザード再起動      |
| 4   | `ChangeStaffDialog` でのボタン配置位置                                                            | Phase1 着手時                              | `modal-action` に `btn btn-ghost` で追加                                     |
| 5   | ~~日時変更更新の原子性（2アクション連続 vs 新アクション）~~                                       | **確定**: 統合アクション方式（本計画参照） | —                                                                            |
| 6   | 連鎖再オープン導線（トーストクリック方式 / 完了ステップ埋め込み方式）                             | Phase 2 実装後に確定                       | 初期はトーストクリック方式を採用。必要なら `cascade-complete` ステップへ切替 |

---

## ブランチ戦略

```
feature/issue-65-adjustment-wizard-shell        ← Phase 0/1
feature/issue-65-helper-change-flow             ← Phase 2
feature/issue-65-datetime-change-flow           ← Phase 3
feature/issue-65-cleanup-old-adjustment         ← Phase 4
```
